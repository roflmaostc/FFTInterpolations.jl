var documenterSearchIndex = {"docs":
[{"location":"#FFTResampling.jl","page":"FFTResampling.jl","title":"FFTResampling.jl","text":"","category":"section"},{"location":"","page":"FFTResampling.jl","title":"FFTResampling.jl","text":"Here you can find the docstrings of all functions.","category":"page"},{"location":"","page":"FFTResampling.jl","title":"FFTResampling.jl","text":"resample\nFFTResampling.sinc_interpolate_sum","category":"page"},{"location":"#FFTResampling.resample","page":"FFTResampling.jl","title":"FFTResampling.resample","text":"resample(arr, new_size [, normalize]; take_real=true, boundary_handling=true)\n\nCalculates the sinc interpolation of an arr on a new array size new_size. It is a re-evaluation of the Fourier series at new grid points. new_size can be arbitrary. Each dimension is then independently either up or downsampled.\n\nThis method is based on FFTs and therefore implicitly assumes periodic boundaries and a finite frequency support. normalize=true by default multiplies by an appropriate factor so that  the average intensity stays the same. If size(new_size)[i] > size(arr)[i], we apply zero padding in Fourier space. If size(new_size)[i] < size(arr)[i], we cut out a centered part of the Fourier spectrum.\n\nWe apply some tricks at the boundary to increase accuracy of highest frequencies.  If you set the keyword argument boundary_handling=false you turn this boundary handling off. This can increase inaccuracies for the highest frequency (not a big problem in real images/signals). However, resample is then faster on CPUs and especially on CUDA GPUs.\n\nExamples\n\njulia> resample([1.0, 2.0, 3.0, 4.0], 8)\n8-element Array{Float64,1}:\n 1.0\n 1.085786437626905\n 2.0\n 2.5\n 3.0\n 3.914213562373095\n 4.0\n 2.5\n\njulia> resample([1.0  2.0; 3.0 4.0], (4,4))\n4×4 Array{Float64,2}:\n 1.0  1.5  2.0  1.5\n 2.0  2.5  3.0  2.5\n 3.0  3.5  4.0  3.5\n 2.0  2.5  3.0  2.5\n\njulia> resample([1.0, 0.0, 1.0, 0.0, 1.0, 0.0], (3))\n3-element Array{Float64,1}:\n 0.5\n 0.5\n 0.5\n\njulia> resample([1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0], (6))\n6-element Array{Float64,1}:\n  1.0\n -0.3333333333333333\n  1.0\n -0.3333333333333333\n  1.0\n -0.3333333333333333\n\njulia> resample([1 2 3; 4 5 6], (3, 2))\n3×2 Array{Float64,2}:\n 1.0   3.0\n 3.25  5.25\n 3.25  5.25\n\n\n\n\n\n","category":"function"},{"location":"#FFTResampling.sinc_interpolate_sum","page":"FFTResampling.jl","title":"FFTResampling.sinc_interpolate_sum","text":"sinc_interpolate_sum(arr, new_length)\n\nCalculates the sinc interpolation of an 1D arr on a new array size new_size.  This method is slow, because of an explicit sum evalulation and not a FFT based evaluation.\n\nExamples\n\njulia> sinc_interpolate_sum([1.0, 2.0, 3.0, 4.0], 8)\n8-element Array{Float64,1}:\n 1.0\n 1.7825353626292277\n 2.0\n 2.1220659078919377\n 3.0\n 4.1592491794681985\n 4.0\n 2.0735615442829793\n\n\n\n\n\n","category":"function"},{"location":"","page":"FFTResampling.jl","title":"FFTResampling.jl","text":"Additionally we have some utility functions:","category":"page"},{"location":"","page":"FFTResampling.jl","title":"FFTResampling.jl","text":"FFTResampling.make_hermitian\nFFTResampling.reverse_all\nFFTResampling.slice\nFFTResampling.center_extract\nFFTResampling.center_set!\nFFTResampling.center_pos\nFFTResampling.get_indices_around_center","category":"page"},{"location":"#FFTResampling.make_hermitian","page":"FFTResampling.jl","title":"FFTResampling.make_hermitian","text":"make_hermitian(arr)\n\nTakes an array arr and appends rows, cols, ... if necessary so that arr is a hermitian array which preserves Parseval's theorem.\n\nExamples\n\njulia> FFTResampling.make_hermitian([1.0 2.0])\n1×3 Array{Float64,2}:\n 0.5  2.0  0.5\n\njulia> FFTResampling.make_hermitian([1.0 2.0; 3.0 4.0])\n3×3 Array{Float64,2}:\n 0.5  1.0  0.0\n 1.5  4.0  1.5\n 0.0  1.0  0.5\n\njulia> FFTResampling.make_hermitian([1im 2.0; 3.0im 4.0im; 5.0 6.0im])\n3×3 Array{Complex{Float64},2}:\n 0.0+0.5im  2.0+0.0im  2.5-0.0im\n 0.0+1.5im  0.0+4.0im  0.0-1.5im\n 2.5+0.0im  0.0+6.0im  0.0-0.5im\n\n\n\n\n\n","category":"function"},{"location":"#FFTResampling.reverse_all","page":"FFTResampling.jl","title":"FFTResampling.reverse_all","text":"reverse_all(arr)\n\nReverse an array arr over all dimensions.\n\nExamples\n\njulia> FFTResampling.reverse_all([1 2 3 4 5])\n1×5 Array{Int64,2}:\n 5  4  3  2  1\n\njulia> FFTResampling.reverse_all([1 2 3 4 5; 7 8 9 10 11])\n2×5 Array{Int64,2}:\n 11  10  9  8  7\n  5   4  3  2  1\n\njulia> FFTResampling.reverse_all([1; 2; 3; 4; 5])\n5-element Array{Int64,1}:\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"#FFTResampling.slice","page":"FFTResampling.jl","title":"FFTResampling.slice","text":"slice(arr, dim, index)\n\nReturn a N dimensional slice (where one dimensions has size 1) of the N-dimensional arr at the index position index in the dim dimension of the array. It holds size(out)[dim] == 1.\n\nExamples\n\njulia> x = [1 2 3; 4 5 6; 7 8 9]\n3×3 Array{Int64,2}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> FFTResampling.slice(x, 1, 1)\n1×3 view(::Array{Int64,2}, 1:1, :) with eltype Int64:\n 1  2  3\n\njulia> FFTResampling.slice(x, 2, 3)\n3×1 view(::Array{Int64,2}, :, 3:3) with eltype Int64:\n 3\n 6\n 9\n\n\n\n\n\n\n","category":"function"},{"location":"#FFTResampling.center_extract","page":"FFTResampling.jl","title":"FFTResampling.center_extract","text":"center_extract(arr, new_size_array)\n\nExtracts a center of an array.  new_size_array must be list of sizes indicating the output size of each dimension. Centered means that a center frequency stays at the center position. Works for even and uneven. If length(new_size_array) < length(ndims(arr)) the remaining dimensions are untouched and copied.\n\nExamples\n\njulia> FFTResampling.center_extract([1 2; 3 4], [1]) \n1×2 Array{Int64,2}:\n 3  4\n\njulia> FFTResampling.center_extract([1 2; 3 4], [1, 1])\n1×1 Array{Int64,2}:\n 4\n\njulia> FFTResampling.center_extract([1 2 3; 3 4 5; 6 7 8], [2 2])\n2×2 Array{Int64,2}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"function"},{"location":"#FFTResampling.center_set!","page":"FFTResampling.jl","title":"FFTResampling.center_set!","text":"center_set!(arr_large, arr_small)\n\nPuts the arr_small central into arr_large. The convention, where the center is, is the same as the definition as for FFT based centered. Function works both for even and uneven arrays.\n\nExamples\n\njulia> FFTResampling.center_set!([1, 1, 1, 1, 1, 1], [5, 5, 5])\n6-element Array{Int64,1}:\n 1\n 1\n 5\n 5\n 5\n 1\n\n\n\n\n\n","category":"function"},{"location":"#FFTResampling.center_pos","page":"FFTResampling.jl","title":"FFTResampling.center_pos","text":"center_pos(x)\n\nCalculate the position of the center frequency. Size of the array is x\n\nExamples\n\njulia> FFTResampling.center_pos(3)\n2\njulia> FFTResampling.center_pos(4)\n3\n\n\n\n\n\n","category":"function"},{"location":"#FFTResampling.get_indices_around_center","page":"FFTResampling.jl","title":"FFTResampling.get_indices_around_center","text":"get_indices_around_center(i_in, i_out)\n\nA function which provides two output indices i1 and i2 where i2 - i1 = i_out The indices are chosen in a way that the set i1:i2 cuts the interval 1:i_in in a way that the center frequency stays at the center position. Works for both odd and even indices\n\n\n\n\n\n","category":"function"}]
}
